controller:
  # MPC Controller Type
  type: "MPC"

  # MPC params
  dt: 0.1
  robot:
    time_discretization_dt: 0.1
  prediction_horizon: 1.0
  ctrl_rate: 10 #hz
  cmd_vel_pub_rate: 100 # hz
  cmd_vel_type: "interpolation"         # integration: publish vel by integrating from acc_bar
                                        # interpolation: publish vel by interpolating vel_bar
  soft_cst: True
  penalize_du: False
  self_collision_avoidance_enabled: True
  static_obstacles_collision_avoidance_enabled: False
  ee_upward_constraint_enabled: False
  cst_tol_schedule_enabled: False
  ee_pose_tracking_enabled: True

  self_collision_emergency_stop: True

  ee_upward_deviation_angle_max: 0.20    # In radians

  collision_constraint_type:
    self: "SignedDistanceConstraint"
    static_obstacles: "SignedDistanceConstraint"

  collision_constraints_softened:
    self: False
    static_obstacles: False

  collision_safety_margin:
    self: 0.25
    static_obstacles: 0.15

  # Soft constraints parameters
  xu_soft:
    mu: 0.001
    zeta: 0.005
  collision_soft:
    self:
      mu: 0.0001
      zeta: 0.005
    static_obstacles:
      mu: 0.0001
      zeta: 0.005

  ee_upward_soft:
    mu: 0.001
    zeta: 0.01

  # Simplified cost function parameters (6 core cost types)
  # The system automatically maps these to specific cost instances based on planner types
  cost_params:
    # End-effector pose cost (used for both Vec3 position and SE3 pose, world and base frames)
    EEPose:
      Qk: [3, 3, 3, 3, 3, 3]  # For SE3: [x, y, z, roll, pitch, yaw]. For Vec3: first 3 used
      P: [1, 1, 1, 1, 1, 1]    # Terminal weights (same structure)
    # End-effector velocity cost (6D: 3D linear + 3D angular for SE3 compatibility)
    EEVel:
      Qk: [1, 1, 1, 1, 1, 1]  # [vx, vy, vz, ωx, ωy, ωz]
      P: [1, 1, 1, 1, 1, 1]    # Terminal weights [vx, vy, vz, ωx, ωy, ωz]
    # Base pose cost (always SE2: [x, y, yaw])
    # Set yaw weight (3rd element) to 0 to disable yaw tracking
    BasePose:
      Qk: [3, 3, 3]  # [x, y, yaw] - set yaw weight to 0 to disable yaw tracking
      P: [1, 1, 1]    # Terminal weights [x, y, yaw]
    # Base velocity cost (always 3D: [vx, vy, vyaw])
    # Set vyaw weight (3rd element) to 0 to disable yaw velocity tracking
    BaseVel:
      Qk: [1, 1, 1]  # [vx, vy, vyaw] - set vyaw weight to 0 to disable yaw velocity tracking
      P: [1, 1, 1]    # Terminal weights [vx, vy, vyaw]
    # Control effort cost (always included)
    Effort:
      Qqa: [0, 0, 0, 0, 0, 0]
      Qqb: [0, 0, 0]
      Qva: [0.01, 0.01, 0.01, 0.01, 0.01, 0.01]
      Qvb: [0.01, 0.01, 0.01]
      Qua: [0.01, 0.01, 0.01, 0.01, 0.01, 0.01]
      Qub: [0.01, 0.01, 0.01]
      Qdua: [0, 0, 0, 0, 0, 0]
      Qdub: [0.1, 0.1, 0.1]
    # Regularization cost (optional)
    Regularization:
      eps: 1.0e-06
    slack:
      z: 10  # linear term
      Z: 1    # quadratic term

  # Line search parameters
  beta: 0.5
  alpha: 0.05

  # ACADOS solver option
  acados:
    name: "MM"
    cython:
      enabled: True
      recompile: False
    raise_exception_on_failure: False
    use_custom_hess: True
    use_terminal_cost: False
    ocp_solver_options:
      qp_solver: "FULL_CONDENSING_HPIPM"
      # FULL_CONDENSING_QPOASES
      # PARTIAL_CONDENSING_HPIPM, FULL_CONDENSING_QPOASES, FULL_CONDENSING_HPIPM,
      # PARTIAL_CONDENSING_QPDUNES, PARTIAL_CONDENSING_OSQP, FULL_CONDENSING_DAQP
      hessian_approx: "GAUSS_NEWTON"
      integrator_type: "IRK"
      print_level: 0
      nlp_solver_type: "SQP_RTI"  #SQP_RTI, SQP
      globalization: "MERIT_BACKTRACKING"
      qp_solver_iter_max: 100
      nlp_solver_tol_comp: 1.e-06
      nlp_solver_tol_stat: 1.0e-03
      nlp_solver_tol_eq: 1.0e-02
      nlp_solver_tol_ineq: 1.0e-02
      nlp_solver_max_iter: 100
      qp_solver_warm_start: 2
      nlp_solver_ext_qp_res: 0
    slack_enabled:
      x: True
      x_e: True
      u: False
      h_0: True
      h: True
      h_e: True

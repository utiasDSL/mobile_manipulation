import argparse
import os

import matplotlib.colors
import pandas
import numpy as np
import seaborn as sns
import holoviews as hv
from holoviews import opts
hv.extension('bokeh')
opts.defaults(opts.HeatMap(radial=True, width=800, height=800, tools=["hover"]))

from mmseq_utils.plotting import DataPlotter, multipage
from matplotlib.colors import LinearSegmentedColormap
from mmseq_utils import math, parsing
import matplotlib.pyplot as plt
import matplotlib.lines as mlines
import matplotlib.patches as mpatches
import matplotlib.transforms as transforms
from pandas import DataFrame, concat
from spatialmath.base import rotz


STYLE_PATH = parsing.parse_ros_path({"package": "mmseq_utils", "path":"scripts/plot_style.mplstyle"})
plt.style.use(STYLE_PATH)
plt.rcParams['pdf.fonttype'] = 42


STATS = [("err_ee", "integral"), ("err_ee", "std"),("err_ee", "max"), ("err_base", "min"),
         ("run_time", "mean"), ("constraints_violation", "mean"),("constraints_violation", "num"),
         ("signed_distance", "min"), ("success", "value")]
YELLOW="#FFAE42"
SCARLET="#cc1d00"
EE_HEIGHT = 0.708
REACHABLE_RADIUS = 1.8605063504325914
EE_POS_HOME = [1.48985, 0.17431, 0.705131]      # copied from generate_random_test
FOOTNOTE_SIZE = 6
def get_optimal_base_err(r_bw_wd, r_ew_wd):
    r_bw_w_opt = (r_bw_wd - r_ew_wd[:2]) / np.linalg.norm(r_bw_wd - r_ew_wd[:2]) * REACHABLE_RADIUS + r_ew_wd[:2]
    return np.linalg.norm(r_bw_wd - r_bw_w_opt)

def construct_logger(path_to_folder):
    """ Path to data folder

    :param path_to_folder:
    :return:
    """
    items = os.listdir(path_to_folder)
    folder_num = 0
    file_num = 0
    for f in items:
        d = os.path.join(path_to_folder, f)
        if os.path.isdir(d):
            folder_num += 1
        else:
            file_num += 1

    if folder_num == 2:
        # if generated by running controller and simulator as two nodes
        # there will be two folders, one by controller and one by simulator
        return SelfCollisionDataPlotter.from_ROSSIM_results(path_to_folder)
    elif folder_num == 1 and file_num ==0:
        # if generated by running controller in loop with simulator,
        # there is only one folder
        return SelfCollisionDataPlotter.from_PYSIM_results(os.path.join(path_to_folder, items[0]))
    elif folder_num == 1 and file_num == 1:
        # if generated by running experiments on the real robot,
        # there is only one folder and one ros bag
        return SelfCollisionDataPlotter.from_ROSEXP_results(path_to_folder)

    return print("Faile to construt logger at " + path_to_folder)

def statistics(plotters):

    stats_dict = {}
    for id, p in enumerate(plotters):
        stats = p.summary(STATS)
        stats_dict[p.data["name"]] = stats

    df = DataFrame.from_dict(stats_dict, orient='index', columns=[p[0] +"_"+ p[1]for p in STATS])

    return df


class SelfCollisionDataPlotter(DataPlotter):
    def __init__(self, data, config=None):
        super().__init__(data, config)
        self._get_statistics_self_collision()

    def _get_statistics_self_collision(self):
        if self.data["statistics"]["signed_distance"]["min"] < self.config["controller"]["collision_safety_margin"]["self"]*0.:
            self.data["statistics"]["success"] = {"value": False}
        else:
            self.data["statistics"]["success"] = {"value": True}

class BenchmarkDataPlotter():

    def __init__(self, folder_path):
        """

        :param folder_path: path to benchmark data folder
        :return:
        """
        # Generate statistics in each test result folder
        # NOTE: Decided not to generate plots here. It takes too much memory space. Generate plots using bash scripts instead.
        if "stats_all.csv" in os.listdir(folder_path):
            df = pandas.read_csv(os.path.join(folder_path, "stats_all.csv"), index_col=[0,1])
            folder_name = "test_13"
            test_folder_path = os.path.join(folder_path, folder_name)
            filename = "HTMPC"
            d = os.path.join(test_folder_path, filename)
            if os.path.isdir(d):
                self.example_plotter = construct_logger(d)
            else:
                self.example_plotter = None
        else:
            dfs = []
            keys = []
            for folder_name in os.listdir(folder_path):
                test_folder_path = os.path.join(folder_path, folder_name)
                if os.path.isdir(test_folder_path):
                    plotters = []
                    for filename in os.listdir(test_folder_path):
                        d = os.path.join(test_folder_path, filename)
                        if os.path.isdir(d):
                            plotter = construct_logger(d)
                            plotters.append(plotter)

                    print(test_folder_path)
                    keys.append(folder_name)
                    dfs.append(statistics(plotters))


            # concatenate data frames
            df = concat(dfs, keys=keys)
            df.to_csv(os.path.join(folder_path, "stats_all.csv"))

        self.folder_path = folder_path
        self.df = df
        self.methods = self.df.index.get_level_values(1).unique().to_list()

    def summarize(self, methods):
        dfs = []
        for name in methods:
            if name in self.methods:
                dfs.append(self.df.xs(name, level=1))

        df_summary = concat([df.mean() for df in dfs], keys=methods, axis=1)
        df_summary.to_csv(os.path.join(self.folder_path, "stats_summary_{}.csv".format('_'.join(methods))))

        return dfs

    def plot(self, dfs, names):
        diff_ee = (dfs[0]["err_ee_integral"] - dfs[1]["err_ee_integral"]) / dfs[1]["err_ee_integral"] * 100
        diff_base = (dfs[0]["err_base_integral"] - dfs[1]["err_base_integral"]) / dfs[1]["err_base_integral"] * 100
        dJ = [diff_ee.to_numpy() , diff_base.to_numpy()]

        f, axes = plt.subplots(1, 1)
        plt.scatter(dJ[0], dJ[1])
        axes.set_xlabel("ΔJ_1 (%)")
        axes.set_ylabel("ΔJ_2 (%)")
        axes.set_title("{} vs {} on Lexicographic Optimality".format(*names))

    def box_plot(self, data_name, dfs, df_names, title=None):
        if title is None:
            title = data_name
        data = [df[data_name] for df in dfs]

        plt.figure()
        plt.boxplot(data, labels=df_names)
        plt.title(title)

    def _convert_header_to_label(self, df, headers, labels, new_header, data_name):
        s = []
        for header in headers:
            s.append(df[header])

        s_new = concat(s, keys=labels, names=new_header).to_frame(data_name)

        return s_new.reset_index()

    def scatter_plot(self, dfs, df_names, x_var_name, y_var_name):
        df = concat(dfs, keys=df_names, names=["Method"])
        plt.figure()
        sns.scatterplot(df, x=x_var_name, y=y_var_name, hue="Method")
        sns.lineplot(df, x=x_var_name, y=y_var_name, hue="Method")
        ax = plt.gca()
        handles, labels = ax.get_legend_handles_labels()
        plt.legend(handles[3:], labels[3:], title='Method')

def benchmark(folder_path):
    data_plotter = BenchmarkDataPlotter(folder_path)
    methods = ["true_acc_bounds", "relaxed_acc_bounds"]

    dfs = data_plotter.summarize(methods)
    print(dfs[0])


def tracking(folder_path):
    plotters = []
    for filename in os.listdir(folder_path):
        d = os.path.join(folder_path, filename)
        if os.path.isdir(d):
            plotter = construct_logger(d)
            plotters.append(plotter)

    axes = None
    for pid, plotter in enumerate(plotters):
        axes = plotter.plot_task_performance(axes=axes, index=pid)

    fig, axes = plt.subplots(2, 1, sharex=True, figsize=(3.5, 2.2))
    shade_region = []
    for pid, plotter in enumerate(plotters):
        plotter.plot_base_tracking(axes[0], pid)
        plotter.plot_singularity(axes[1], pid)

        index = np.where(plotter.data["arm_manipulability"] < 0.1)
        if len(index[0]) == 0:
            index = np.where(plotter.data["arm_manipulability"] < 0.2)
        shade_region.append([plotter.data["ts"][index][0], plotter.data["ts"][index][-1]])

    plotters[0].plot_optimal_error(axes[0])

    axes[0].tick_params(axis='both', labelsize=FOOTNOTE_SIZE)
    axes[1].tick_params(axis='both', labelsize=FOOTNOTE_SIZE)
    axes[1].set_xlabel("Time (s)", fontsize=FOOTNOTE_SIZE, y=-0.05)
    shade_region = np.array(shade_region)
    shade_start = max(shade_region[:, 0])
    shade_end = min(shade_region[:, 1])
    ylims = []
    for ax in axes:
        ylims.append(ax.set_ylim())

    axes[0].fill_between(np.linspace(shade_start, shade_end, 100), -0.2, 2.2, facecolor=SCARLET, alpha=0.15)
    axes[1].fill_between(np.linspace(shade_start, shade_end, 100), -0.2, 1.2, facecolor=SCARLET, alpha=0.15)
    for ax, ylim in zip(axes, ylims):
        ax.set_ylim(ylim)
    # t1 = axes[0].text(4, 0.0, "Part 1 (Peak)",
    #             ha="center", va="center", rotation=0,
    #             bbox=dict(boxstyle="darrow,pad=0.3",
    #                       fc="white", ec="steelblue"))

    axes_fraction_y = 0.1
    an12 = axes[0].annotate("",
                           xy=(0.0, -axes_fraction_y), xycoords=("data", "axes fraction"), xytext=(8, -axes_fraction_y),
                           arrowprops=dict(arrowstyle="<->", lw=1.))
    an11 = axes[0].annotate("Part 1 (Peak)",
                      xy=(4, -axes_fraction_y), xycoords=("data", "axes fraction"),
                      va="center", ha="center",
                      bbox=dict(boxstyle="round", fc="w"), fontsize=FOOTNOTE_SIZE)

    an22 = axes[0].annotate("",
                           xy=(8, -axes_fraction_y), xycoords=("data", "axes fraction"), xytext=(16., -axes_fraction_y),
                           arrowprops=dict(arrowstyle="<->", lw=1.))

    an21 = axes[0].annotate("Part 2 (Valley)",
                      xy=(12, -axes_fraction_y), xycoords=("data", "axes fraction"),
                      va="center", ha="center",
                      bbox=dict(boxstyle="round", fc="w"), fontsize=FOOTNOTE_SIZE)

    an_sing_arr = axes[1].annotate("",
                            xy=(shade_start, 0.25), xycoords="data",
                            xytext=(shade_end, 0.25),
                            arrowprops=dict(arrowstyle="<->", lw=1.))
    an_sing_text = axes[1].annotate("Singular\nConfiguration",
                            xy=(np.mean([shade_start, shade_end]), 0.5), xycoords="data",
                            va="center", ha="center",
                            bbox=dict(boxstyle="round", fc="w"), fontsize=FOOTNOTE_SIZE)
    plt.subplots_adjust(top=0.97,
                        bottom=0.168,
                        left=0.135,
                        right=0.977,
                        hspace=0.222,
                        wspace=0.0)
    fig.savefig(folder_path+"/Error Plot.pdf", pad_inches=0)

    plt.show()

def cost(folder_path):
    plotters = []
    for filename in sorted(os.listdir(folder_path)):
        d = os.path.join(folder_path, filename)
        if os.path.isdir(d):
            plotter = construct_logger(d)
            plotters.append(plotter)

    axes = None
    legends = ["HTMPC_Baseline_Constraint_No_Tol", "HTMPC_Baseline_Constraints_New", "HTMPC"]
    for pid, plotter in enumerate(plotters):
        axes, fig = plotter.plot_mpc_cost(axes=axes, index=pid, titles=["Task 1: EE Tracking Cost", "Task 2: Base Tracking Cost"])
    for ax in axes:
        ax.grid('on')
    plt.subplots_adjust(top=0.92,
                        bottom=0.135,
                        left=0.1,
                        right=0.955,
                        hspace=0.245,
                        wspace=0.2)
    fig.savefig(folder_path+"/Cost.pdf", pad_inches=0)
    plt.show()



if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument('-f', "--folder", required=True, help="Path to data folder.")

    args = parser.parse_args()

    benchmark(args.folder)



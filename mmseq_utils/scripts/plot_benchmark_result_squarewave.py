import argparse
import os

import matplotlib.colors
import pandas
import numpy as np
import seaborn as sns
import holoviews as hv
from holoviews import opts
hv.extension('bokeh')
opts.defaults(opts.HeatMap(radial=True, width=800, height=800, tools=["hover"]))

from mmseq_utils.logging import DataLogger
from mmseq_utils.plotting import DataPlotter, multipage
from matplotlib.colors import LinearSegmentedColormap
from mmseq_utils import math, parsing
import matplotlib.pyplot as plt
import matplotlib.lines as mlines
import matplotlib.patches as mpatches
import matplotlib.transforms as transforms
from pandas import DataFrame, concat
from spatialmath.base import rotz


STYLE_PATH = parsing.parse_ros_path({"package": "mmseq_utils", "path":"scripts/plot_style.mplstyle"})
plt.style.use(STYLE_PATH)
plt.rcParams['pdf.fonttype'] = 42


STATS = [("err_ee", "integral"), ("err_ee", "std"),("err_base_normalized", "integral"),("err_ee", "max"),
         ("err_ee_1", "integral"), ("err_base_normalized_1", "integral"),
         ("err_ee_2", "integral"), ("err_base_normalized_2", "integral"),
         ("cmd_accs_saturation", "mean"),
         ("cmd_jerks_base_linear", "max"),
         ("run_time", "mean"), ("constraints_violation", "mean"),("constraints_violation", "num"),
         ("phi", "value"),
         ("r", "value")]
YELLOW="#FFAE42"
SCARLET="#cc1d00"
EE_HEIGHT = 0.708
REACHABLE_RADIUS = 1.8605063504325914
EE_POS_HOME = [1.48985, 0.17431, 0.705131]      # copied from generate_random_test
FOOTNOTE_SIZE = 6
def get_optimal_base_err(r_bw_wd, r_ew_wd):
    r_bw_w_opt = (r_bw_wd - r_ew_wd[:2]) / np.linalg.norm(r_bw_wd - r_ew_wd[:2]) * REACHABLE_RADIUS + r_ew_wd[:2]
    return np.linalg.norm(r_bw_wd - r_bw_w_opt)

def construct_logger(path_to_folder):
    """ Path to data folder

    :param path_to_folder:
    :return:
    """
    items = os.listdir(path_to_folder)
    folder_num = 0
    file_num = 0
    for f in items:
        d = os.path.join(path_to_folder, f)
        if os.path.isdir(d):
            folder_num += 1
        else:
            file_num += 1

    if folder_num == 2:
        # if generated by running controller and simulator as two nodes
        # there will be two folders, one by controller and one by simulator
        return SquareWaveDataPlotter.from_ROSSIM_results(path_to_folder)
    elif folder_num == 1 and file_num ==0:
        # if generated by running controller in loop with simulator,
        # there is only one folder
        return SquareWaveDataPlotter.from_PYSIM_results(os.path.join(path_to_folder, items[0]))
    elif folder_num == 1 and file_num == 1:
        # if generated by running experiments on the real robot,
        # there is only one folder and one ros bag
        return SquareWaveDataPlotter.from_ROSEXP_results(path_to_folder)

    return print("Faile to construt logger at " + path_to_folder)

def statistics(plotters):

    stats_dict = {}
    for id, p in enumerate(plotters):
        stats = p.summary(STATS)
        stats_dict[p.data["name"]] = stats

    df = DataFrame.from_dict(stats_dict, orient='index', columns=[p[0] +"_"+ p[1]for p in STATS])

    return df

class SquareWaveDataPlotter(DataPlotter):
    def __init__(self, data, config=None):
        super().__init__(data, config)
        self._get_statistics_squarewave()

    def _get_statistics_squarewave(self):
        N = np.argwhere(np.linalg.norm(self.data["r_bw_w_ds"] - self.data["r_bw_w_ds"][-10], axis=1) < 1e-3).flatten()[0]
        self.data["err_ee_1"] = self.data["err_ee"][:N]
        self.data["err_ee_2"] = self.data["err_ee"][N:]
        # assume that controller achieves optimal error 10 steps before the second waypoint
        eb_opt = get_optimal_base_err(self.data["r_bw_w_ds"][0], self.data["r_ew_w_ds"][-10])
        # eb_opt = self.data["err_base"][N-10]

        self.data["err_base_normalized_1"] = (self.data["err_base"][:N]) / (self.data["err_base"][0])
        self.data["err_base_normalized_2"] = self.data["err_base"][N:] / self.data["err_base"][N]

        data_names = ["err_ee_1", "err_ee_2", "err_base_normalized_1", "err_base_normalized_2"]
        t1 = self.data["ts"][:N]
        t2 = self.data["ts"][N:]
        for name in data_names:
            stats = math.statistics(self.data[name])
            t = t1 if name.split("_")[-1] == "1" else t2
            self.data["statistics"][name] = {"rms": math.rms_continuous(t, np.abs(self.data[name])),
                                                   "integral": math.integrate_zoh(t, np.abs(self.data[name])),
                                                   "mean": stats[0], "max": stats[1],
                                                   "min": stats[2]}

        r_be_w = self.data["r_bw_w_ds"][0] - self.data["r_ew_w_ds"][0][:2]
        self.data["statistics"]["phi"] = {"value": math.wrap_to_2_pi_scalar(np.arctan2(r_be_w[1], r_be_w[0]))}
        self.data["statistics"]["r"] = {"value": np.linalg.norm(r_be_w)}

    def plot_mpc_cost(self, axes, index=0, legend=None, titles=None):
        cost = self.data.get("mpc_cost_finals")
        t_sim = self.data["ts"]
        half_time_index = len(t_sim)//2
        if cost[half_time_index-20, 1] > 10:
            task_1_failed = True
        else:
            task_1_failed = False

        N,  task_num = cost.shape

        if legend is None:
            legend = self.data["name"]

        if axes is None:
            f, axes = plt.subplots(task_num, 1, sharex=True, figsize=(3.5, 2.5))
        else:
            f = plt.gcf()

        colors = sns.color_palette("ch:s=.35,rot=-.35", n_colors=4)
        colors = sns.color_palette()
        # cm = LinearSegmentedColormap.from_list("my_list", colors, N=50)
        for l in range(task_num):
            if l !=1 or not task_1_failed:
                axes[l].plot(t_sim, cost[:, l], label=legend, color=colors[index], linewidth=1.3)
            else:
                axes[l].plot(t_sim[:half_time_index-20], cost[:half_time_index-20, l], label=legend, color=colors[index], linewidth=1.3)
                axes[l].scatter(t_sim[half_time_index-20], cost[half_time_index-20, l], marker='x', color='r', s=15)
            if titles is None:
                axes[l].set_title("Task " + str(l) + " Final Cost")
            else:
                axes[l].set_title(titles[l])

        axes[0].legend()
        axes[1].set_xlabel("Time (s)")

        return axes, f

    def plot_task_performance(self, axes=None, index=0, legend=None):
        if axes is None:
            f, axes = plt.subplots(4, 1, sharex=True)
        else:
            if len(axes) != 4:
                raise ValueError("Given axes number ({}) does not match task number ({}).".format(len(axes), 4))

        if legend is None:
            legend = self.data["name"]

        prop_cycle = plt.rcParams["axes.prop_cycle"]
        colors = prop_cycle.by_key()["color"]

        t_sim = self.data["ts"]
        nq = int(self.data["nq"])
        xs_sat, us_sat = self.model_interface.robot.checkBounds(self.data["xs"], self.data["cmd_accs"], -1e-3)
        axes[0].plot(t_sim, self.data["constraints_violation"]*100, label=legend + " mean = {:.3f}".format(self.data["statistics"]["constraints_violation"]["mean"]*100), color=colors[index])
        axes[0].set_ylabel("constraints violation (%)")

        axes[1].plot(t_sim, self.data["err_ee"],
                     label=legend + " acc = {:.3f}".format(self.data["statistics"]["err_ee"]["integral"]), color=colors[index])
        axes[1].set_ylabel("EE Err (m)")

        N = np.argwhere(np.linalg.norm(self.data["r_bw_w_ds"] - self.data["r_bw_w_ds"][-10], axis=1) < 1e-3).flatten()[0]
        axes[2].plot(t_sim[:N], self.data["err_base_normalized_1"],
                     label=legend + " part 1 acc = {:.3f}".format(self.data["statistics"]["err_base_normalized_1"]["integral"]), color=colors[index])
        axes[2].plot(t_sim[N:] - t_sim[N], self.data["err_base_normalized_2"], linestyle="--",
                     label=legend + " part 2 acc = {:.3f}".format(self.data["statistics"]["err_base_normalized_2"]["integral"]),
                     color=colors[index])
        axes[2].set_ylabel("Base Err (m)")

        axes[3].plot(t_sim, self.data["arm_manipulability"], label=legend)
        axes[3].set_ylabel("Arm Manipulability")
        axes[3].set_xlabel("Time (s)")

        for a in axes:
            a.legend()

        return axes

    def plot_base_tracking(self, axes=None, index=0, legend=None):
        if axes is None:
            f, axes = plt.subplots(1,1)

        if legend is None:
            legend = self.data["name"]

        prop_cycle = plt.rcParams["axes.prop_cycle"]
        colors = prop_cycle.by_key()["color"]
        colors = sns.color_palette()

        t_sim = self.data["ts"]
        axes.plot(t_sim, self.data["err_base"],
                     label=legend, color=colors[index], linewidth=1.3)

        axes.set_ylabel("Base Err (m)", fontsize=FOOTNOTE_SIZE)
        axes.legend(fontsize=FOOTNOTE_SIZE)
        axes.grid('on')

        # axes.annotate("Optimal error",
        #                  xy=(t_sim[int(N/2)], err_opt_1), xycoords="data",
        #                  xytext=(0.1, 0.1),
        #                  va="center", ha="center",
        #                  bbox=dict(boxstyle="round", fc="w"), fontsize=FOOTNOTE_SIZE)

        return axes

    def plot_optimal_error(self, axes=None):
        if axes is None:
            f, axes = plt.subplots(1,1)
        N = np.argwhere(np.linalg.norm(self.data["r_bw_w_ds"] - self.data["r_bw_w_ds"][-10], axis=1) < 1e-3).flatten()[
            0]
        err_opt_1 = get_optimal_base_err(self.data["r_bw_w_ds"][0], self.data["r_ew_w_ds"][0])
        err_opt_2 = 0
        err_opt_1_array = np.repeat(err_opt_1, N)
        err_opt_2_array = np.repeat(err_opt_2, len(self.data["ts"]) - N)
        err_opt = np.hstack((err_opt_1_array, err_opt_2_array))

        t_sim = self.data["ts"]
        axes.plot(t_sim, err_opt, '--', color=SCARLET, linewidth=1.5, label="optimal error")
        axes.legend(fontsize=FOOTNOTE_SIZE)

    def plot_base_tracking_normalized(self, axes=None, index=0, legend=None):
        if axes is None:
            f, axes = plt.subplots(1,1)

        if legend is None:
            legend = self.data["name"]

        prop_cycle = plt.rcParams["axes.prop_cycle"]
        colors = prop_cycle.by_key()["color"]

        t_sim = self.data["ts"]
        N = np.argwhere(np.linalg.norm(self.data["r_bw_w_ds"] - self.data["r_bw_w_ds"][-10], axis=1) < 1e-3).flatten()[
            0]
        axes.plot(t_sim, np.hstack((self.data["err_base_normalized_1"],self.data["err_base_normalized_2"])),
                  color=colors[index],label=legend, linewidth=1.3)
        axes.set_ylabel("Base Err (Normalized)", fontsize=FOOTNOTE_SIZE)
        axes.legend(fontsize=FOOTNOTE_SIZE)
        axes.grid('on')

        return axes

    def plot_singularity(self, axes=None, index=0, legend=None):
        if axes is None:
            f, axes = plt.subplots(1, 1)

        if legend is None:
            legend = self.data["name"]

        prop_cycle = plt.rcParams["axes.prop_cycle"]
        colors = prop_cycle.by_key()["color"]

        t_sim = self.data["ts"]
        axes.plot(t_sim, self.data["arm_manipulability"], label=legend, color=colors[index], linewidth=1.3)
        axes.set_ylabel("Arm Singularity", fontsize=FOOTNOTE_SIZE)
        axes.legend(fontsize=FOOTNOTE_SIZE)
        axes.grid('on')


        return axes

class BenchmarkDataPlotter():

    def __init__(self, folder_path):
        """

        :param folder_path: path to benchmark data folder
        :return:
        """
        # Generate statistics in each test result folder
        # NOTE: Decided not to generate plots here. It takes too much memory space. Generate plots using bash scripts instead.
        if "stats_all.csv" in os.listdir(folder_path):
            df = pandas.read_csv(os.path.join(folder_path, "stats_all.csv"), index_col=[0,1])
            folder_name = "test_13"
            test_folder_path = os.path.join(folder_path, folder_name)
            filename = "HTMPC"
            d = os.path.join(test_folder_path, filename)
            if os.path.isdir(d):
                self.example_plotter = construct_logger(d)
            else:
                self.example_plotter = None
        else:
            dfs = []
            keys = []
            for folder_name in os.listdir(folder_path):
                test_folder_path = os.path.join(folder_path, folder_name)
                if os.path.isdir(test_folder_path):
                    plotters = []
                    for filename in os.listdir(test_folder_path):
                        d = os.path.join(test_folder_path, filename)
                        if os.path.isdir(d):
                            plotter = construct_logger(d)
                            plotters.append(plotter)

                    print(test_folder_path)
                    keys.append(folder_name)
                    dfs.append(statistics(plotters))


            # concatenate data frames
            df = concat(dfs, keys=keys)
            df.to_csv(os.path.join(folder_path, "stats_all.csv"))

        self.folder_path = folder_path
        self.df = df
        self.methods = self.df.index.get_level_values(1).unique().to_list()

    def summarize(self, methods):
        dfs = []
        for name in methods:
            if name in self.methods:
                dfs.append(self.df.xs(name, level=1))

        df_summary = concat([df.mean() for df in dfs], keys=methods, axis=1)
        df_summary.to_csv(os.path.join(self.folder_path, "stats_summary_{}.csv".format('_'.join(methods))))

        return dfs

    def plot(self, dfs, names):
        diff_ee = (dfs[0]["err_ee_integral"] - dfs[1]["err_ee_integral"]) / dfs[1]["err_ee_integral"] * 100
        diff_base = (dfs[0]["err_base_integral"] - dfs[1]["err_base_integral"]) / dfs[1]["err_base_integral"] * 100
        dJ = [diff_ee.to_numpy() , diff_base.to_numpy()]

        f, axes = plt.subplots(1, 1)
        plt.scatter(dJ[0], dJ[1])
        axes.set_xlabel("ΔJ_1 (%)")
        axes.set_ylabel("ΔJ_2 (%)")
        axes.set_title("{} vs {} on Lexicographic Optimality".format(*names))

    def plot_mean_error(self, dfs, names):
        """

        :param dfs: list of two dataframes
        :param names:
        :return:
        """
        num_dfs = len(dfs)
        # End Effector
        f1, axes1 = plt.subplots(2, 1, sharex=True)
        for i in range(num_dfs):
            axes1[0].hist(dfs[i]["err_ee_1_integral"], bins=100, label=names[i], alpha=0.5)
            axes1[1].hist(dfs[i]["err_ee_2_integral"], bins=100, label=names[i], alpha=0.5)

        axes1[0].set_title("t = 0 ~ 8s")
        axes1[1].set_title("t = 8 ~ 16s")
        axes1[1].set_xlabel("mean end effector tracking error (m)")

        # Base
        f2, axes2 = plt.subplots(2, 1, sharex=True)
        for i in range(num_dfs):
            axes2[0].hist(dfs[i]["err_base_normalized_1_integral"], bins=100, label=names[i], alpha=0.5)
            axes2[1].hist(dfs[i]["err_base_normalized_2_integral"], bins=100, label=names[i], alpha=0.5)

        axes2[0].set_title("t = 0 ~ 8s")
        axes2[1].set_title("t = 8 ~ 16s")
        axes2[1].set_xlabel("mean base tracking error (normalized)")
        for k in range(2):
            axes1[k].legend()
            axes2[k].legend()

    def box_plot(self, data_name, dfs, df_names, title=None):
        if title is None:
            title = data_name
        data = [df[data_name] for df in dfs]

        plt.figure()
        plt.boxplot(data, labels=df_names)
        plt.title(title)

    def _convert_header_to_label(self, df, headers, labels, new_header, data_name):
        s = []
        for header in headers:
            s.append(df[header])

        s_new = concat(s, keys=labels, names=new_header).to_frame(data_name)

        return s_new.reset_index()

    def violin_plot(self, dfs, df_names, x_labels=None, axes=None, base_only=False):
        df = concat(dfs, keys=df_names, names=["Method"])
        df_ee = self._convert_header_to_label(df, ["err_ee_1_integral", "err_ee_2_integral"], ["part 1", "part 2"], ["Square Wave"], "Mean Error (m)")
        df_base = self._convert_header_to_label(df, ["err_base_normalized_1_integral", "err_base_normalized_2_integral"], ["part 1", "part 2"], ["Square Wave"], "Mean Normalized Error")
        df_ee.to_csv(os.path.join(self.folder_path, "err_ee_{}_stacked.csv".format('_'.join(df_names))))
        df_base.to_csv(os.path.join(self.folder_path, "err_base_{}_stacked.csv".format('_'.join(df_names))))
        with sns.color_palette("ch:s=.35,rot=-.35", n_colors=3):
            if axes is None:
                if not base_only:
                    fig, axes = plt.subplots(2,1,figsize=(3.5, 3.5))
                    axes_ee = axes[0]
                    axes_base = axes[1]
                else:
                    fig, axes_base = plt.subplots(figsize=(3.5, 2.))
                    axes = [axes_base]
            legend_handles = []
            if not base_only:
                sns.stripplot(data=df_ee, y='Method', x="Mean Error (m)", hue="Square Wave", jitter=False, edgecolor='black', linewidth=0.6, ax=axes[0], size=3)
                sns.violinplot(df_ee, y="Method", x="Mean Error (m)", hue="Square Wave", inner=None, split=True, scale="count", orient="h", cut=1.25, ax=axes[0], width=0.8, linewidth=0.8)
                handles, labels = axes_ee.get_legend_handles_labels()
                l1 = axes_ee.legend(handles[2:], labels[2:], title='Task 1: EE Tracking', fontsize=FOOTNOTE_SIZE)
                legend_handles.append(l1)
                # left, right = plt.xlim()
                # plt.xlim([0, right])
                # axes[0].set_title("Task 1: End Effector Tracking Error", fontsize=FOOTNOTE_SIZE)
                if x_labels:
                    axes_ee.set_yticklabels(x_labels)


            sns.stripplot(df_base, y="Method", x="Mean Normalized Error", hue="Square Wave", jitter=False, edgecolor='black', linewidth=0.6, ax=axes_base, size=3)
            sns.violinplot(df_base, y="Method", x="Mean Normalized Error", hue="Square Wave", inner=None, split=True, scale="count", orient="h", ax=axes_base, width=0.8,linewidth=0.8)
            handles, labels = axes_base.get_legend_handles_labels()
            l2 = axes_base.legend(handles[2:], labels[2:], title='Task 2: Base Tracking', fontsize=FOOTNOTE_SIZE)
            legend_handles.append(l2)

            # axes[1].set_title("Task 2: Base Tracking Error (Normalized)", fontsize=FOOTNOTE_SIZE)
            if x_labels:
                axes_base.set_yticklabels(x_labels)

            for l in legend_handles:
                plt.setp(l.get_title(), fontsize=FOOTNOTE_SIZE)

            for ax in axes:
                ax.tick_params(axis="both", which="both", labelsize=FOOTNOTE_SIZE)
                for tick in ax.get_yticklabels():
                    tick.set_rotation(60)
        if not base_only:
            plt.subplots_adjust(top=0.975,
                                bottom=0.095,
                                left=0.125,
                                right=0.9,
                                hspace=0.24,
                                wspace=0.2)
        else:
            plt.subplots_adjust(top=0.98,
                                bottom=0.18,
                                left=0.145,
                                right=0.96,
                                hspace=0.24,
                                wspace=0.2)
        return axes, fig

    def scatter_plot(self, dfs, df_names, x_var_name, y_var_name):
        df = concat(dfs, keys=df_names, names=["Method"])
        plt.figure()
        sns.scatterplot(df, x=x_var_name, y=y_var_name, hue="Method")
        sns.lineplot(df, x=x_var_name, y=y_var_name, hue="Method")
        ax = plt.gca()
        handles, labels = ax.get_legend_handles_labels()
        plt.legend(handles[3:], labels[3:], title='Method')

    def radial_heat_map(self, dfs, df_names, x_var_name, y_var_name, title=None, ax=None):
        # df = concat(dfs, keys=df_names, names=["Method"])
        # df.rename(columns={y_var_name: "values"}, inplace=True)
        for df in dfs:
            df.sort_values(x_var_name, inplace=True)
        df = dfs[0]
        mid = (df[x_var_name][-1] + df[x_var_name][0])/2
        angle = df[x_var_name] - mid + np.pi/2
        radius = np.linspace(0, 1.5, 5) + 0.5
        R,th = np.meshgrid(radius, angle)
        z = np.vstack([df[y_var_name] for df in dfs]).T
        nans = np.zeros((z.shape[0],1)) * np.nan
        z_padded = np.c_[z[:, 0], nans, z[:,1], nans, z[:,2]]

        colors = sns.color_palette("ch:s=.35,rot=-.35", n_colors=3)
        cm = LinearSegmentedColormap.from_list(
            "my_list", colors, N=50)
        cm = sns.diverging_palette(140, 15, s=65, l=45, sep=1, n=50, center='light', as_cmap=True)

        if ax is None:
            fig, ax = plt.subplots(subplot_kw={'projection': 'polar'}, figsize=(3.5,2.5))
        else:
            fig = plt.gca()
        # Defining the colormesh to define the color as per the values
        mc = plt.pcolormesh(th, R, z_padded, cmap=cm)
        # PLotting the figure
        plt.plot(angle, R, ls='none')

        # Annotation
        impacted_area = mpatches.Ellipse((0., radius[-1]/2), height=0.5,width=2.5, angle=-90,facecolor=(0, 0, 0, .0125), edgecolor=SCARLET,
                                    transform=ax.transData._b, linewidth=1.3)
        ax.add_patch(impacted_area)
        ax.annotate("Negatively impacted \nby singularity", xy=(np.pi/2+0.1, 1.5), xycoords="data",
                    xytext=(5*np.pi/6 , 3.0),
                    horizontalalignment='center', arrowprops=dict(arrowstyle="->", lw=1.),
                    fontsize=FOOTNOTE_SIZE)

        cb = plt.colorbar(mc, ax=ax, pad=0.005, location="right", shrink=0.5)
        cb.ax.tick_params(labelsize=FOOTNOTE_SIZE)
        ax.set_rmax(2.5)
        ax.set_xticks((np.arange(12)+1) / 6. * np.pi)
        # ax.set_xticklabels(["", "", "90°", "","", "180°", "","","270°", "","","0°"], fontsize=FOOTNOTE_SIZE)
        ax.set_xticklabels([])
        ax.set_yticks(radius[0::2])
        ax.set_yticklabels([])
        ax.set_xlim([angle[0], angle[-1]])
        ax.set_aspect('equal')

        # Remove all spines
        ax.set_frame_on(False)
        # Set grid with some transparency
        ax.grid(alpha=0.4)
        if title:
            # ax.set_title(title, fontsize=FOOTNOTE_SIZE)
            ax.text(
                np.pi / 2, radius[-1]+0.75, title, ha="center", va="center", fontsize=FOOTNOTE_SIZE, fontweight='bold'
            )
        else:
            ax.set_title(y_var_name)

        # Define the characteristics of the bbox behind the text we add
        bbox_dict = {
            "facecolor": "w", "edgecolor": colors[-1], "linewidth": 1,
            "boxstyle": "round", "pad": 0.15
        }
        # Iterate over types of plastics and add the labels
        for r, name in zip(radius[0::2], df_names):
            ax.text(
                np.pi/6, r, name, color=colors[-1], ha="center", va="top",
                 bbox=bbox_dict, fontsize=FOOTNOTE_SIZE
            )

        plt.subplots_adjust(top=1.0,
                            bottom=0.0,
                            left=0.15,
                            right=1.0,
                            hspace=0.2,
                            wspace=0.2)

        return ax, fig

    def radial_heat_map_seperate(self, dfs, df_names, x_var_name, y_var_name, title=None, ax=None):
        # df = concat(dfs, keys=df_names, names=["Method"])
        # df.rename(columns={y_var_name: "values"}, inplace=True)
        df_num = len(dfs)
        for df in dfs:
            df.sort_values(x_var_name, inplace=True)
        df = dfs[0]
        angle = df[x_var_name] - np.median(df[x_var_name]) + np.pi/2
        radius = np.linspace(0, 1.5, 3) + 0.5
        R, th = np.meshgrid(radius, angle)
        z = np.vstack([df[y_var_name] for df in dfs]).T
        nans = np.zeros((z.shape[0], 1)) * np.nan
        z_paddeds = []
        for i in range(df_num):
            z_padded = np.c_[nans, z[:, i], nans]
            z_paddeds.append(z_padded)

        colors = sns.color_palette("ch:s=.35,rot=-.35", n_colors=3)
        cm = LinearSegmentedColormap.from_list(
            "my_list", colors, N=50)
        cm = sns.diverging_palette(140, 15, s=65, l=45, sep=1, n=50, center='light', as_cmap=True)

        if ax is None:
            fig, axes = plt.subplots(1, df_num,subplot_kw={'projection': 'polar'}, figsize=(3.5,1.5))
        else:
            fig = plt.gca()
        # Defining the colormesh to define the color as per the values


        mcs = []
        bbox_dict = {
            "facecolor": "w", "edgecolor": colors[-1], "linewidth": 1,
            "boxstyle": "round", "pad": 0.15
        }
        for i in range(df_num):
            mc = axes[i].pcolormesh(th, R, z_paddeds[i], cmap=cm)
            mcs.append(mc)
            # axes[i].set_title(df_names[i])
            axes[i].set_xticks([])
            axes[i].set_xticklabels([])
            axes[i].set_yticks([])
            axes[i].set_yticklabels([])
            axes[i].set_xlim([angle[0], angle[-1]])
            axes[i].set_rlim([0, 1.5])

            # Remove all spines
            axes[i].set_frame_on(False)
            # Set grid with some transparency
            axes[i].grid("on", alpha=0.4)

# # Define the characteristics of the bbox behind the text we add

            # Iterate over types of plastics and add the labels
            axes[i].text(
                np.pi/2, radius[0], df_names[i], color=colors[-1], ha="center", va="bottom",
                 bbox=bbox_dict, fontsize=FOOTNOTE_SIZE)



        # PLotting the figure
        plt.plot(angle, R, ls='none')
        plt.tight_layout()

        # Annotation
        # impacted_area = mpatches.Ellipse((-radius[2], -0.14), height=0.5,width=2.5, angle=13,facecolor=(0, 0, 0, .0125), edgecolor=SCARLET,
        #                             transform=ax.transData._b, linewidth=1.3)
        # ax.add_patch(impacted_area)
        # ax.annotate("Negatively impacted \nby singularity", xy=(np.pi-0.1, 1.5), xycoords="data",
        #             xytext=(np.pi - 0.3, 3.0),
        #             horizontalalignment='center', arrowprops=dict(arrowstyle="->", lw=1.),
        #             fontsize=FOOTNOTE_SIZE)
        #
        # cb = plt.colorbar(mc, ax=ax, pad=0.005, location="right", shrink=0.5)
        # cb.ax.tick_params(labelsize=FOOTNOTE_SIZE)
        # ax.set_rmax(2.5)
        # ax.set_xticks((np.arange(12)+1) / 6. * np.pi)
        # # ax.set_xticklabels(["", "", "90°", "","", "180°", "","","270°", "","","0°"], fontsize=FOOTNOTE_SIZE)
        # ax.set_xticklabels([])
        # ax.set_yticks(radius[0::2])
        # ax.set_yticklabels([])
        # ax.set_xlim([angle[0], angle[-1]])
        # ax.set_aspect('equal')
        #
        # # Remove all spines
        # ax.set_frame_on(False)
        # # Set grid with some transparency
        # ax.grid(alpha=0.4)
        # if title:
        #     ax.set_title(title, fontsize=FOOTNOTE_SIZE)
        # else:
        #     ax.set_title(y_var_name)
        #
        # # Define the characteristics of the bbox behind the text we add
        # bbox_dict = {
        #     "facecolor": "w", "edgecolor": colors[-1], "linewidth": 1,
        #     "boxstyle": "round", "pad": 0.15
        # }
        # # Iterate over types of plastics and add the labels
        # for r, name in zip(radius[0::2], df_names):
        #     ax.text(
        #         np.pi/2, r, name, color=colors[-1], ha="center", va="bottom",
        #          bbox=bbox_dict, fontsize=FOOTNOTE_SIZE
        #     )
        #
        # plt.subplots_adjust(top=0.929,
        #                     bottom=5.2e-18,
        #                     left=0.11,
        #                     right=0.877,
        #                     hspace=0.2,
        #                     wspace=0.2)

        return ax, fig

    def add_arrow_to_line2D(self,
            axes, line, arrow_locs=[0.2, 0.4, 0.6, 0.8],
            arrowstyle='-|>', arrowsize=1, transform=None):
        """
        Add arrows to a matplotlib.lines.Line2D at selected locations.
        credit : https://stackoverflow.com/questions/26911898/matplotlib-curve-with-arrow-ticks

        Parameters:
        -----------
        axes:
        line: Line2D object as returned by plot command
        arrow_locs: list of locations where to insert arrows, % of total length
        arrowstyle: style of the arrow
        arrowsize: size of the arrow
        transform: a matplotlib transform instance, default to data coordinates

        Returns:
        --------
        arrows: list of arrows
        """
        if not isinstance(line, mlines.Line2D):
            raise ValueError("expected a matplotlib.lines.Line2D object")
        x, y = line.get_xdata(), line.get_ydata()

        arrow_kw = {
            "arrowstyle": arrowstyle,
            "mutation_scale": 10 * arrowsize,
        }

        color = line.get_color()
        use_multicolor_lines = isinstance(color, np.ndarray)
        if use_multicolor_lines:
            raise NotImplementedError("multicolor lines not supported")
        else:
            arrow_kw['color'] = color

        linewidth = line.get_linewidth()
        if isinstance(linewidth, np.ndarray):
            raise NotImplementedError("multiwidth lines not supported")
        else:
            arrow_kw['linewidth'] = linewidth

        if transform is None:
            transform = axes.transData

        arrows = []
        for loc in arrow_locs:
            s = np.cumsum(np.sqrt(np.diff(x) ** 2 + np.diff(y) ** 2))
            n = np.searchsorted(s, s[-1] * loc)
            arrow_tail = (x[n], y[n])
            arrow_head = (np.mean(x[n:n + 2]), np.mean(y[n:n + 2]))
            p = mpatches.FancyArrowPatch(
                arrow_tail, arrow_head, transform=transform,
                **arrow_kw)
            axes.add_patch(p)
            arrows.append(p)
        return arrows
    def plot_squarewave_tasks(self, df, ax=None, scale=1):
        colors = sns.color_palette("ch:s=.35,rot=-.35", n_colors=3)
        cm = LinearSegmentedColormap.from_list(
            "my_list", colors, N=50)

        if ax is None:
            fig, ax = plt.subplots(subplot_kw={'projection': 'polar'}, figsize=(3.5, 2.5))
            df_sorted = df.sort_values("phi_value", inplace=False)

            mid = ( df_sorted["phi_value"][-1] + df_sorted["phi_value"][0]) / 2

        else:
            fig = plt.gca()

        # Plot Reachable Area
        reachable_area = plt.Circle((0, 0), radius=REACHABLE_RADIUS, facecolor=(0, 0, 0, .0125), edgecolor=cm(0.2),
                                    transform=ax.transData._b, linewidth=1.0)
        ax.add_artist(reachable_area)
        ax.annotate("Workspace\nBoundary", xy=(np.pi / 2, REACHABLE_RADIUS), xycoords="data",
                    xytext=(np.pi / 2, REACHABLE_RADIUS * 0.75),
                    horizontalalignment='center', fontsize=FOOTNOTE_SIZE*scale)

        # Plot Example Path
        r_bw_bs = self.example_plotter.data.get("r_bw_bs", [])
        r_bw_ees = r_bw_bs - np.array(EE_POS_HOME)[:2]
        r_bw_b_ds = self.example_plotter.data.get("r_bw_b_ds", [])
        N = np.argwhere(np.linalg.norm(r_bw_b_ds - r_bw_b_ds[-10], axis=1) < 1e-3).flatten()[0]

        R = rotz(-mid+np.pi/2)
        r_bw_ees = np.hstack((r_bw_ees, np.zeros((r_bw_ees.shape[0], 1))))
        r_bw_ees = (R @ r_bw_ees.T).T
        line1, = ax.plot(r_bw_ees[:N, 0], r_bw_ees[:N, 1], color=cm(0.4), transform=ax.transData._b, linewidth=1.3, label="Part 1")
        line2, = ax.plot(r_bw_ees[N:, 0], r_bw_ees[N:, 1], color=cm(0.8), transform=ax.transData._b, linewidth=1.3, label="Part 2")

        self.add_arrow_to_line2D(ax, line1, arrow_locs=[0.2, 0.4, 0.6, 0.8],
                            arrowstyle='-|>', arrowsize=1, transform=ax.transData._b)
        self.add_arrow_to_line2D(ax, line2, arrow_locs=[0.2, 0.4, 0.6, 0.8],
                                 arrowstyle='-|>', arrowsize=1, transform=ax.transData._b)



        # Plot Peak
        df_new = df.reset_index()
        phi_peaks = df_new[df_new["index"]!="test_13"]["phi_value"]
        r_peaks = df_new[df_new["index"]!="test_13"]["r_value"]
        ax.scatter(phi_peaks, r_peaks, facecolors=cm(0.5), edgecolors=cm(0.5), linewidth=1, s=10)
        ax.scatter(df.xs("test_13")["phi_value"], df.xs("test_13")["r_value"],
                   facecolors=YELLOW, edgecolors=YELLOW, linewidth=1.5, s=10, marker="*", label="Peak Target")
        ax.annotate("", xy=(phi_peaks[5], r_peaks[5]), xycoords="data",
                    xytext=(np.pi- 0.8, 3.0),
                    horizontalalignment='center', arrowprops=dict(arrowstyle="->", lw=1.), fontsize=FOOTNOTE_SIZE*scale)
        ax.annotate("", xy=(phi_peaks[3], r_peaks[3]), xycoords="data",
                    xytext=(np.pi-0.8, 3.0),
                    horizontalalignment='center', arrowprops=dict(arrowstyle="->", lw=1.), fontsize=FOOTNOTE_SIZE*scale)
        ax.annotate("Base Targets\n (Peak)", xy=(phi_peaks[8], r_peaks[8]), xycoords="data",
                    xytext=(np.pi - 0.8, 3.0),
                    horizontalalignment='center', arrowprops=dict(arrowstyle="->", lw=1.), fontsize=FOOTNOTE_SIZE*scale)

        # Plot Valley
        base_target_valley = -np.array(EE_POS_HOME)[:2]
        phi_valley = math.wrap_to_2_pi_scalar(np.arctan2(base_target_valley[1], base_target_valley[0]))
        r_valley = np.linalg.norm(base_target_valley)
        ax.scatter(phi_valley, r_valley,
                   facecolors=YELLOW, s=10)
        ax.annotate("Base Home/\nTarget (Valley)", xy=(phi_valley, r_valley), xycoords="data", xytext=(np.pi, r_valley*0.7),
                    horizontalalignment='center', fontsize=FOOTNOTE_SIZE*scale)


        # Plot EE Target
        ax.scatter(0, 0, facecolors=SCARLET, linewidth=1.5, s=60)
        ax.annotate("EE Home/Target", xy=(0.0, 0), xycoords="data", xytext=(0, 0.4), horizontalalignment='center', fontsize=FOOTNOTE_SIZE*scale)

        ax.set_xticks(math.wrap_to_2_pi_array((np.arange(12)+1) / 6. * np.pi + mid - np.pi/2))
        # ax.set_xticklabels(["","", "90°", "","", "180°", "","","270°", "","","0°"], fontsize=FOOTNOTE_SIZE*scale)
        ax.set_xticklabels([])
        ax.set_yticks([0, 1, 2])
        ax.set_yticklabels(["0 m", "1 m", "2 m"], fontsize=FOOTNOTE_SIZE*scale)
        ax.set_rlabel_position(135)
        ax.set_frame_on(False)
        ax.set_title("Random Square Wave Tests", fontsize=FOOTNOTE_SIZE*scale, fontweight="bold")
        legend = ax.legend(loc="upper center", ncol=1, bbox_to_anchor=(-0.1, 0.9), borderaxespad=0., title="HTMPC Results", fontsize=FOOTNOTE_SIZE*scale)
        plt.setp(legend.get_title(), fontsize=FOOTNOTE_SIZE*scale)
        ax.grid(alpha=0.4)
        ax.set_aspect('equal')
        ax.set_rmax(2.5)


        plt.subplots_adjust(top=0.929,
                            bottom=5.2e-18,
                            hspace=0.2,
                            wspace=0.2)
        ax.set_theta_zero_location(loc="E", offset=(-mid + np.pi / 2) / np.pi * 180)

        return ax, fig



def benchmark(folder_path):
    data_plotter = BenchmarkDataPlotter(folder_path)
    # methods = ["HTIDKC", "HTMPC_WPT", "HTMPC"]
    # methods = ["HTMPC_Baseline_Constraint_No_Tol", "HTMPC_Baseline_Constraints_New", "HTMPC"]
    methods = ["Baseline - High Tolerance", "Baseline - No Tolerance", "Our - High Tolerance", "Our - No Tolerance"]
    # names = ["Baseline\nLexConstraint\n(No_Tol)", "Baseline\nLexConstraint\n(with_Tol)", "Proposed\nLexConstraint\n(with_Tol)"]

    dfs = data_plotter.summarize(methods)
    print(dfs[0])
    data_plotter.plot_mean_error(dfs, methods)
    data_plotter.box_plot("cmd_jerks_base_linear_max", dfs, methods, "Maximum Commanded Base Jerk (Linear) (m/s^3)")
    data_plotter.box_plot("run_time_mean", dfs, methods, "Run Time (s)")
    data_plotter.violin_plot(dfs, methods, methods)

    plt.show()

def ral_paper(folder_path):
    data_plotter = BenchmarkDataPlotter(folder_path)
    methods = ["HTIDKC", "HTMPC_WPT", "HTMPC"]

    dfs = data_plotter.summarize(methods)
    # data_plotter.plot_mean_error(dfs, methods)
    # data_plotter.box_plot("cmd_jerks_base_linear_max", dfs, methods, "Maximum Commanded Base Jerk (Linear) (m/s^3)")
    # data_plotter.box_plot("run_time_mean", dfs, methods, "Run Time (s)")
    _, fig_vio = data_plotter.violin_plot(dfs, methods, base_only=True)
    # data_plotter.scatter_plot(dfs, methods,"phi_value" ,"err_base_normalized_integral")
    # data_plotter.scatter_plot(dfs, methods,"phi_value" ,"err_base_normalized_1_integral")
    # data_plotter.scatter_plot(dfs, methods,"phi_value" ,"err_base_normalized_2_integral")
    _,fig_singularity = data_plotter.radial_heat_map(dfs, methods,"phi_value" ,"err_base_normalized_integral", "Base Tracking Error (Normalized)")
    # _,fig_singularity = data_plotter.radial_heat_map_seperate(dfs, methods,"phi_value" ,"err_base_normalized_integral", "Base Tracking Error (Normalized)")
    _, fig_task = data_plotter.plot_squarewave_tasks(dfs[-1])

    fig_vio.savefig(folder_path + "/Tracking.pdf", pad_inches=0)
    fig_singularity.savefig(folder_path + "/Singularity.pdf",pad_inches=0)
    fig_task.savefig(folder_path + "/TestCases.pdf",pad_inches=0)
    plt.show()

def tracking(folder_path):
    plotters = []
    for filename in os.listdir(folder_path):
        d = os.path.join(folder_path, filename)
        if os.path.isdir(d):
            plotter = construct_logger(d)
            plotters.append(plotter)

    axes = None
    for pid, plotter in enumerate(plotters):
        axes = plotter.plot_task_performance(axes=axes, index=pid)

    fig, axes = plt.subplots(2, 1, sharex=True, figsize=(3.5, 2.2))
    shade_region = []
    for pid, plotter in enumerate(plotters):
        plotter.plot_base_tracking(axes[0], pid)
        plotter.plot_singularity(axes[1], pid)

        index = np.where(plotter.data["arm_manipulability"] < 0.1)
        if len(index[0]) == 0:
            index = np.where(plotter.data["arm_manipulability"] < 0.2)
        shade_region.append([plotter.data["ts"][index][0], plotter.data["ts"][index][-1]])

    plotters[0].plot_optimal_error(axes[0])

    axes[0].tick_params(axis='both', labelsize=FOOTNOTE_SIZE)
    axes[1].tick_params(axis='both', labelsize=FOOTNOTE_SIZE)
    axes[1].set_xlabel("Time (s)", fontsize=FOOTNOTE_SIZE, y=-0.05)
    shade_region = np.array(shade_region)
    shade_start = max(shade_region[:, 0])
    shade_end = min(shade_region[:, 1])
    ylims = []
    for ax in axes:
        ylims.append(ax.set_ylim())

    axes[0].fill_between(np.linspace(shade_start, shade_end, 100), -0.2, 2.2, facecolor=SCARLET, alpha=0.15)
    axes[1].fill_between(np.linspace(shade_start, shade_end, 100), -0.2, 1.2, facecolor=SCARLET, alpha=0.15)
    for ax, ylim in zip(axes, ylims):
        ax.set_ylim(ylim)
    # t1 = axes[0].text(4, 0.0, "Part 1 (Peak)",
    #             ha="center", va="center", rotation=0,
    #             bbox=dict(boxstyle="darrow,pad=0.3",
    #                       fc="white", ec="steelblue"))

    axes_fraction_y = 0.1
    an12 = axes[0].annotate("",
                           xy=(0.0, -axes_fraction_y), xycoords=("data", "axes fraction"), xytext=(8, -axes_fraction_y),
                           arrowprops=dict(arrowstyle="<->", lw=1.))
    an11 = axes[0].annotate("Part 1 (Peak)",
                      xy=(4, -axes_fraction_y), xycoords=("data", "axes fraction"),
                      va="center", ha="center",
                      bbox=dict(boxstyle="round", fc="w"), fontsize=FOOTNOTE_SIZE)

    an22 = axes[0].annotate("",
                           xy=(8, -axes_fraction_y), xycoords=("data", "axes fraction"), xytext=(16., -axes_fraction_y),
                           arrowprops=dict(arrowstyle="<->", lw=1.))

    an21 = axes[0].annotate("Part 2 (Valley)",
                      xy=(12, -axes_fraction_y), xycoords=("data", "axes fraction"),
                      va="center", ha="center",
                      bbox=dict(boxstyle="round", fc="w"), fontsize=FOOTNOTE_SIZE)

    an_sing_arr = axes[1].annotate("",
                            xy=(shade_start, 0.25), xycoords="data",
                            xytext=(shade_end, 0.25),
                            arrowprops=dict(arrowstyle="<->", lw=1.))
    an_sing_text = axes[1].annotate("Singular\nConfiguration",
                            xy=(np.mean([shade_start, shade_end]), 0.5), xycoords="data",
                            va="center", ha="center",
                            bbox=dict(boxstyle="round", fc="w"), fontsize=FOOTNOTE_SIZE)
    plt.subplots_adjust(top=0.97,
                        bottom=0.168,
                        left=0.135,
                        right=0.977,
                        hspace=0.222,
                        wspace=0.0)
    fig.savefig(folder_path+"/Error Plot.pdf", pad_inches=0)

    plt.show()

def cost(folder_path):
    plotters = []
    for filename in sorted(os.listdir(folder_path)):
        d = os.path.join(folder_path, filename)
        if os.path.isdir(d):
            plotter = construct_logger(d)
            plotters.append(plotter)

    axes = None
    legends = ["HTMPC_Baseline_Constraint_No_Tol", "HTMPC_Baseline_Constraints_New", "HTMPC"]
    for pid, plotter in enumerate(plotters):
        axes, fig = plotter.plot_mpc_cost(axes=axes, index=pid, titles=["Task 1: EE Tracking Cost", "Task 2: Base Tracking Cost"])
    for ax in axes:
        ax.grid('on')
    plt.subplots_adjust(top=0.92,
                        bottom=0.135,
                        left=0.1,
                        right=0.955,
                        hspace=0.245,
                        wspace=0.2)
    fig.savefig(folder_path+"/Cost.pdf", pad_inches=0)
    plt.show()



if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument('-f', "--folder", required=True, help="Path to data folder.")
    parser.add_argument("--compare", action="store_true",
                        help="plot comparisons")
    parser.add_argument("--tracking", action="store_true",
                        help="plot tracking comparisons")
    parser.add_argument("--cost", action="store_true",
                        help="plot tracking comparisons")
    parser.add_argument("--ral", action="store_true",
                        help="plot tracking comparisons")
    args = parser.parse_args()
    if args.tracking:
        tracking(args.folder)
    elif args.cost:
        cost(args.folder)
    elif args.ral:
        ral_paper(args.folder)
    else:
        benchmark(args.folder)


